#include <iostream>
#include <sstream>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <vector>
#include <iomanip>
#include <set>
#include <map>
#include <stack>
#include <queue>
using namespace std;

typedef unsigned long long L;
typedef long long LL;
#define LP(i, a, b) for (int i = int(a); i < int(b); i++)
#define LPE(i, a, b) for (int i = int(a); i <= int(b); i++)
typedef pair<int, int> PII;
typedef vector<vector<PII> > WAL;
typedef vector<vector<int> > SAL;
typedef pair<int, int> PII;
#define INF 2000000000
#define Ep 1e-9

/*
 unknown:
 # of distinct sets of vertex

 known:
 list of points

 conditions:
 points are generated by a formula, similar to how hashing works

 set has 3 members

 sum of 3 members x and y coordinates mod 3 = 0

 subproblems:
 1. based on previous exp, what do we know of mod ops:
 mod op forms a group of size 3 (0,1,2)
 2. i.e., all 3 element sets can be reduced to a pattern, combination of 0,1,2, notice this reduction is more of one-way not reversible
 3. this means, instead of search from numbers => patterns, we should go patterns => numbers,
 4. so each point is one of 9 possible patterns, we can do a complete search on patterns to figure out what combos will give the required result
 for each 3-element pattern, # of incarnations = # pattern1 + # of patterns2 + # of patterns3

 for each point,
 calculate the point pattern, and increase the count

 for i in pattern 1
 for j in pattern 2, j >= i
 for k in pattern 3, k >= pattern
 if x[i] + x[j] + x[k] % 3 == 0
 && y[i] + y[k] + y[j] % 3 == 0
 totalcount += num[i] * num[j] * num[k]
 */

int N, n, A, B, C, D, x_0;
int y_0, M;

int num[3][3];
L total;

void genNums() {
	L X = x_0;
	L Y = y_0;

	num[(X % 3)][(Y % 3)]++;
	LPE(i, 1, n-1)
	{
		X = (A * X + B) % M;
		Y = (C * Y + D) % M;

		num[(X % 3)][(Y % 3)]++;
	}
}

/*
 void genNums() {
 while (n--) {
 num[x_0 % 3][y_0 % 3]++;
 long long x1 = (A * x_0 + B) % M;
 long long y1 = (C * y_0 + D) % M;
 x_0 = x1;
 y_0 = y1;
 }
 }
 */

void calcMatches() {

	LP (i, 0 , 9)
	{
		int xi = i / 3;
		int yi = i % 3;

		L ni = num[xi][yi];
		//printf ("%d ", ni);

		if (!ni)
			continue;

		LP(j, i, 9)
		{
			int xj = j / 3;
			int yj = j % 3;
			L nj = num[xj][yj];

			if (!nj)
				continue;

			LP(k, j, 9)
			{
				int xk = k / 3;
				int yk = k % 3;
				L nk = num[xk][yk];

				if (!nk)
					continue;

				if ((xi + xj + xk) % 3 || (yi + yj + yk) % 3)
					continue;

				L combo = 0;

				if (xi == xj && yi == yj && xj == xk && yj == yk) {
					combo = nk * (nk - 1) * (nk - 2); //all from the same
					combo /= 6;
				} else if (xi == xj && yi == yj) {
					combo = nk * ni * (ni - 1);
					combo /= 2;
				} else if (xj == xk && yj == yk) {
					combo = ni * nj * (nj - 1);
					combo /= 2;
				} else if (xk == xi && yk == yi) {
					combo = nj * nk * (nk - 1);
					combo /= 2;
				} else {
					combo = ni * nj * nk;
				}

				total += combo;
			}
		}
	}
}

int main() {
	freopen("/Users/georgeli/Downloads/A-large-practice.in", "r", stdin);
//	freopen("/Users/georgeli/B_1.in", "r", stdin);
//freopen("/Users/georgeli/A-small-practice.in", "r", stdin);
	freopen("/Users/georgeli/A_small.out", "w", stdout);

	scanf("%d", &N);

	LPE(cn, 1, N)
	{
		total = 0;

		//printf("memset!\n");

		LP(i, 0, 3)
		{
			//			printf("%d\n", sizeof(num[i]));

			memset(num[i], 0, sizeof(num[i]));
		}

		scanf("%d %d %d %d %d %d %d %d", &n, &A, &B, &C, &D, &x_0, &y_0, &M);
		//		printf("%d %d %d %d %d %d %d %d\n", n, A, B, C, D, x_0, y_0, M);

		genNums();

		calcMatches();

		printf("Case #%d: %llu\n", cn, total);

	}

	return 0;
}
