--------

WLOG, assume, P/Q are of lowest fraction

P/Q = (A* D + B*C) / (D *B * 2)

Insight 1: q must be of form 2^gen

1st gen: 1, 0, 1/2
2nd gen, 1, 0, 1/2, 3/4, 1/4
3rd gen, 0, 1/8, 1/4, 3/8....

Cliam: all possible numbers cover all digits

if there is no 1 in the family at all => P must be 0, i.e, at least 1'1 in first gen, 

1st gen,
1,1/2
second gen
1 1/4, 3/4,

so odd case, partition into 1 + even => and even is from 1

to get min number, lowest 1 => max share

given P/Q
sanitize: P != 0, P <= Q, Q must of form 2^n

Gen(P,Q)
{
	if(P == 1)
		get answer based on value of Q
	if(P%2 == 0)
		return Gen(P/2, Q/2)
	else
		return 1 + Gen(P-1, Q/2)
}
-----
C:
consider the case ab
if b has multple choices, i.e., many b*, then these b* should connect, , or invalide, i.e, at most 1 form of 
i.e, at most 1 form of b*, remaining bb

so with ab, the b* as tail is fixed!
same as *a

so preprocess
if there is one with form abc, the answer is 0
2 sets, of form aa, of form ab
in 2nd set
each letter can appear in head at most once, in tail at most one
otherwise error


cur head = first
cur tail = first

foreach (in ab set)
	if can head
		head
	if can tail
		tail

for each break, including head/tail
	overall * # of aa!

try to connect to last head/tail with same

distince at head or tail

------------
(FAILED)
N, M, K points

insight: the optimal solution must have symetric structure => symmetric to the long end, symmetric to both ends

in a generation approach: generate symmetric patterns, can calculate points.
We will bsearch to find closest one, add extra stones to fill the difference

To solve small input:
start from base row, just guess the number
for num of empties from 1..n
	for each row
		for each  guess
			calc the enclosure based on previous orw 
