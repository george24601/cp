claim: if A <= B, then step(A) <= step(B)
proof:  doenst work! the sample data disagrees

claim: in an optimal solution, if we reverse, we only go from low to high
proof: if high to low, 
1. we can not lose digit, because we have to go through the add until new digit step again, i.e., we will hit a value we have generated
already, redundant step
2. if we swap to low so we can work on the other end, we can work on the other end first, then swap, and then work on this end, saves 1
swap.so the solution wont be optimal

claim: reverse is used no more than once, in the optimal solution, except for adding digit
proof: similar idea, consider the case of 2 swaps

op0 -> swap1 -> op1 -> swap2 -> op2

we know swap happens only during the same digit, we can just combine op0 and op2, and save 1 swap, note that this combination is possible,
because we know the add will not affect digits in the other half. Otherwise, the solution will not be optimal => because it is cheaper to do
the work pre-swap

but if there is only 1 swap, this happens only when we are done with the work on the far end and satified with it, and then we swap

so the flow becomes

while length < required length
  10*1 -> 10*9 -> 90*1 ->99*9

when we reach the desired digit, we start at 10*1 (special case for 10*0) 
we do add until the reversed is the farend, and then swap, and then work on the remaining end
if the last digit is 0, then we do step(N-1) + 1 (last step is an add)
